"""
from __future__ import annotations

import os

from dotenv import load_dotenv
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.db.init import database, init_models
from app.route import auth, test

load_dotenv()

FRONTEND_ORIGIN = os.getenv("FRONTEND_ORIGIN", "http://127.0.0.1:5500")

print("FRONTEND_ORIGIN:", FRONTEND_ORIGIN)

app = FastAPI(title="FastAPI Cookie JWT Auth")


@app.on_event("startup")
async def startup() -> None:
    print("Connecting to database and creating models...")
    init_models()
    await database.connect()


@app.on_event("shutdown")
async def shutdown() -> None:
    print("Disconnecting from database...")
    await database.disconnect()


app.add_middleware(
    CORSMiddleware,
    allow_origins=[FRONTEND_ORIGIN],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(auth.router, prefix="/auth", tags=["auth"])
app.include_router(test.router, prefix="/test", tags=["test"])


@app.get("/")
async def root():
    return {"Welcome": "FastAPI server (JWT in HttpOnly cookies)"}

""" app\main.py

"""

""" app\__init__.py

"""
import os

from dotenv import load_dotenv
from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import declarative_base, sessionmaker
from databases import Database

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./app.db")

metadata = MetaData()
Base = declarative_base(metadata=metadata)

engine = create_engine(DATABASE_URL, future=True)
database = Database(DATABASE_URL)

SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)


def init_models() -> None:
    from app.db import model  # noqa: F401
    Base.metadata.create_all(bind=engine)

""" app\db\init.py

"""
from datetime import datetime

from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, Text, TIMESTAMP

from app.db.init import Base


class Auth(Base):
    __tablename__ = "auth"

    uid = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(255), nullable=False)
    email = Column(String(255), nullable=False, unique=True)
    password = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    create_time = Column(TIMESTAMP, default=datetime.utcnow)
    update_time = Column(TIMESTAMP, default=datetime.utcnow)


class Token(Base):
    __tablename__ = "token"

    token_id = Column(Integer, primary_key=True, autoincrement=True)
    uid = Column(Integer, ForeignKey("auth.uid"), nullable=False)
    access_token = Column(Text, nullable=False)
    refresh_token = Column(Text, nullable=False)
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    expires_at = Column(TIMESTAMP, nullable=False)

""" app\db\model.py

"""

""" app\db\__init__.py

"""
from __future__ import annotations

import os
from datetime import datetime, timedelta
from typing import Any, Dict

from dotenv import load_dotenv
from fastapi import HTTPException, status
from jose import ExpiredSignatureError, JWTError, jwt
from passlib.context import CryptContext

load_dotenv()

JWT_KEY = os.getenv("JWT_KEY", "dev_secret_key_change_me_123456!")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60
REFRESH_TOKEN_EXPIRE_DAYS = 7

pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def _create_token(data: Dict[str, Any], expires_delta: timedelta) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + expires_delta
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, JWT_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def create_access_token(sub: int) -> str:
    return _create_token(
        data={"sub": str(sub), "type": "access"},
        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES),
    )


def create_refresh_token(sub: int) -> str:
    return _create_token(
        data={"sub": str(sub), "type": "refresh"},
        expires_delta=timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS),
    )


def decode_token(token: str, expected_type: str) -> int:
    try:
        payload = jwt.decode(token, JWT_KEY, algorithms=[ALGORITHM])
        token_type = payload.get("type")
        uid = payload.get("sub")

        if token_type != expected_type or uid is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token",
            )
        return int(uid)
    except ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
        )
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

""" app\lib\security.py

"""

""" app\lib\__init__.py

"""
from __future__ import annotations

from datetime import datetime, timedelta
from typing import Optional

from fastapi import APIRouter, Body, Depends, HTTPException, Request, Response, status

from app.db.init import database
from app.db.model import Auth, Token
from app.lib.security import (
    ACCESS_TOKEN_EXPIRE_MINUTES,
    create_access_token,
    create_refresh_token,
    decode_token,
    hash_password,
    verify_password,
)

router = APIRouter()

ACCESS_COOKIE_NAME = "access_token"
REFRESH_COOKIE_NAME = "refresh_token"

COOKIE_SECURE = False
COOKIE_SAMESITE = "lax"


async def get_current_uid(request: Request) -> int:
    token = request.cookies.get(ACCESS_COOKIE_NAME)
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
        )
    return decode_token(token, expected_type="access")


def set_auth_cookies(response: Response, access_token: str, refresh_token: str) -> None:
    response.set_cookie(
        key=ACCESS_COOKIE_NAME,
        value=access_token,
        httponly=True,
        secure=COOKIE_SECURE,
        samesite=COOKIE_SAMESITE,
        max_age=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
    )
    response.set_cookie(
        key=REFRESH_COOKIE_NAME,
        value=refresh_token,
        httponly=True,
        secure=COOKIE_SECURE,
        samesite=COOKIE_SAMESITE,
        max_age=7 * 24 * 60 * 60,
    )


def clear_auth_cookies(response: Response) -> None:
    response.delete_cookie(ACCESS_COOKIE_NAME)
    response.delete_cookie(REFRESH_COOKIE_NAME)


@router.post("/signup")
async def signup(data: dict = Body(...)):
    email: Optional[str] = data.get("email")
    username: Optional[str] = data.get("username")
    password: Optional[str] = data.get("password")
    print(email)
    return 
    if not email or not username or not password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email, username, and password are required.",
        )

    existing = await database.fetch_one(
        Auth.__table__.select().where(Auth.email == email)
    )
    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email already registered.",
        )

    hashed = hash_password(password)

    query = Auth.__table__.insert().values(
        email=email,
        username=username,
        password=hashed,
        create_time=datetime.utcnow(),
    )
    await database.execute(query)

    return {"status": "ok", "message": "Signup successful."}


@router.post("/signin")
async def signin(response: Response, data: dict = Body(...)):
    email: Optional[str] = data.get("email")
    password: Optional[str] = data.get("password")

    if not email or not password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email and password are required.",
        )

    user = await database.fetch_one(
        Auth.__table__.select().where(Auth.email == email)
    )
    if not user or not verify_password(password, user["password"]):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password.",
        )

    uid = int(user["uid"])
    access_token = create_access_token(uid)
    refresh_token = create_refresh_token(uid)

    existing_token = await database.fetch_one(
        Token.__table__.select().where(Token.uid == uid)
    )
    expires_at = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    if existing_token:
        query = (
            Token.__table__
            .update()
            .where(Token.uid == uid)
            .values(
                access_token=access_token,
                refresh_token=refresh_token,
                created_at=datetime.utcnow(),
                expires_at=expires_at,
            )
        )
    else:
        query = Token.__table__.insert().values(
            uid=uid,
            access_token=access_token,
            refresh_token=refresh_token,
            created_at=datetime.utcnow(),
            expires_at=expires_at,
        )
    await database.execute(query)

    set_auth_cookies(response, access_token, refresh_token)

    return {"status": "ok", "email": user["email"], "username": user["username"]}


@router.post("/signout")
async def signout(request: Request, response: Response):
    access_token = request.cookies.get(ACCESS_COOKIE_NAME)
    uid: Optional[int] = None
    if access_token:
        try:
            uid = decode_token(access_token, expected_type="access")
        except HTTPException:
            uid = None

    if uid is not None:
        delete_q = Token.__table__.delete().where(Token.uid == uid)
        await database.execute(delete_q)

    clear_auth_cookies(response)
    return {"status": "ok", "message": "Signed out."}


@router.get("/me")
async def me(uid: int = Depends(get_current_uid)):
    user = await database.fetch_one(
        Auth.__table__.select().where(Auth.uid == uid)
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found.",
        )
    return {
        "uid": user["uid"],
        "email": user["email"],
        "username": user["username"],
        "is_active": user["is_active"],
    }

""" app\route\auth.py

"""
from __future__ import annotations

from fastapi import APIRouter

router = APIRouter()


@router.get("/")
async def test_root():
    return {"message": "The routing is working well."}

""" app\route\test.py

"""

""" app\route\__init__.py